<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SSE-Lang Input Syntax v0.1.1</title>
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin: 24px; line-height: 1.45; }
    .wrap { max-width: 960px; margin: 0 auto; }
    h1 { font-size: 22px; margin-bottom: 12px; }
    h2 { font-size: 16px; margin-top: 22px; }
    pre { background:#f7f7f7; padding:12px; border-radius:12px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:13px; }
    .nav { margin-bottom:16px; font-size:13px; opacity:0.85; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="nav"><a href="/sse-lang/check/">← Back to Judgement Endpoint</a></div>
  <h1>SSE-Lang Input Syntax v0.1.1 (Public Checker)</h1>
  <p>SSE-Lang Input Syntax v0.1.1 (Public Checker)</p>
<pre><code>Status: Public demonstrator syntax for the SSE-Lang judgement endpoint.
Scope: Defines the input language accepted by the public checker at /sse-lang/check/.
Non-goal: This syntax does not disclose the full rule system; it only standardizes how inputs are expressed for feasibility screening.</code></pre>
<h2>1. Overview</h2>
<p>The SSE-Lang judgement endpoint accepts a sequence of statements terminated by semicolons.<br/>Statements set semantic fields (key-value assignments) and may include an explicit evaluation command.</p>
<pre><code>Minimal pattern:
Key: Value;
...
CHECK;</code></pre>
<p>The checker normalizes the parsed assignments into a field → value mapping and evaluates them against the SSE-Lang v0.1 infeasibility ruleset.</p>
<h2>2. Lexical Conventions</h2>
<h2>2.1 Whitespace</h2>
<p>Spaces, tabs, and newlines may appear between tokens and do not affect meaning.</p>
<h2>2.2 Comments</h2>
<p>Single-line comments start with // and continue to end-of-line.</p>
<pre><code>IonPathDimensionality: #3D; // comment</code></pre>
<h2>2.3 Identifiers</h2>
<p>Note: String literals may not contain newlines in v0.1.1.</p>
<p>Identifiers (ident) are used for keys and enum segments:<br/>	•	Must start with [A-Za-z_]<br/>	•	May contain [A-Za-z0-9_\-]</p>
<p>Examples:<br/>	•	IonPathDimensionality<br/>	•	DataReliability<br/>	•	ModerateOrWorseCount</p>
<h2>3. Grammar (EBNF)
program      := statement* EOF ;</h2>
<pre><code>statement    := assign &quot;;&quot; 
             | query &quot;;&quot; ;</code></pre>
<pre><code>assign       := ident ( &quot;:&quot; | &quot;=&quot; ) value ;</code></pre>
<pre><code>query        := &quot;CHECK&quot; | &quot;EVAL&quot; ;</code></pre>
<pre><code>value        := number
             | string
             | symbol
             | enumPath ;</code></pre>
<pre><code>enumPath     := ident ( &quot;.&quot; ident )* ;</code></pre>
<pre><code>symbol       := &quot;#&quot; ident ;</code></pre>
<pre><code>string       := &#x27;&quot;&#x27; { CHAR - &#x27;&quot;&#x27; } &#x27;&quot;&#x27; ;</code></pre>
<pre><code>ident        := /[A-Za-z_][A-Za-z0-9_\-]*/ ;
number       := /-?\d+(\.\d+)?/ ;</code></pre>
<h2>4. Semantics</h2>
<h2>4.1 Assignments</h2>
<p>Assignments set a field value:</p>
<pre><code>IonPathDimensionality: #3D;
DataReliability = reliability.partial;
ModerateOrWorseCount: 2;</code></pre>
<p>Duplicate keys overwrite earlier values (last assignment wins).</p>
<h2>4.2 Evaluation Query</h2>
<p>The query statement is optional in the current public demonstrator:</p>
<pre><code>CHECK;</code></pre>
<p>	•	If present, it indicates an explicit evaluation point.<br/>	•	If absent, the checker still evaluates using all parsed assignments.</p>
<pre><code>Both CHECK; and EVAL; are accepted and equivalent in v0.1.1.</code></pre>
<p>In v0.1.1, CHECK/EVAL marks an evaluation point but does not introduce segmented or multi-stage execution.</p>
<h2>5. Normalization Rules (Critical for Reproducibility)</h2>
<p>The public checker applies the following normalizations before rule evaluation:</p>
<h2>5.1 Key Canonicalization</h2>
<p>Input keys are mapped to canonical rule fields using the ruleset alias table (rules.json → aliases).<br/>If a key matches an alias (case-insensitive), it is rewritten to the canonical field name.</p>
<p>Example mapping (illustrative):<br/>	•	IonPathDimensionality → Ion Path Dimensionality<br/>	•	DataReliability → Data Reliability</p>
<p>If no alias matches, the key is used as-is.</p>
<h2>5.2 Value Normalization</h2>
<p>Numbers<br/>	•	Parsed as integer or float.</p>
<pre><code>Strings
	•	&quot;...&quot;
	•	Preserved then lowercased for comparison.</code></pre>
<p>Symbols<br/>	•	#3D parses as the symbol 3D<br/>	•	Normalized to lower-case for evaluation: 3d</p>
<pre><code>Enum Paths
	•	reliability.partial parses as segments [&quot;reliability&quot;,&quot;partial&quot;]
	•	Normalized by taking the last segment and lowercasing: partial</code></pre>
<p>This is designed to allow domain-qualified enums without burdening v0.1 rule comparators.</p>
<h2>6. Examples</h2>
<h2>6.1 Minimal Feasibility Check</h2>
<pre><code>IonPathDimensionality: #3D;
PathContinuity: #flexible;
DataReliability: reliability.partial;
ModerateOrWorseCount: 2;
CHECK;</code></pre>
<h2>6.2 Using Strings and Numbers</h2>
<pre><code>SynthesisAccessibility: &quot;difficult&quot;;
ElectrochemicalWindow: 4.8;
EVAL;</code></pre>
<h2>6.3 With Comments</h2>
<pre><code>IonPathDimensionality: #1D; // low dimensionality
DataReliability: reliability.full;
CHECK;</code></pre>
<h2>7. Error Handling</h2>
<p>The parser reports:<br/>	•	A short error message<br/>	•	A line/column location<br/>	•	A context snippet with a caret pointer</p>
<pre><code>Typical errors:
	•	Missing semicolon ;
	•	Unterminated string &quot;...
	•	Unexpected character
	•	Invalid value position</code></pre>
<h2>8. Backward Compatibility (Legacy Input)</h2>
<p>For continuity, the public checker may also accept legacy “Key: Value” line format when the input does not resemble SSE-Lang syntax.</p>
<p>Legacy example:</p>
<p>Ion Path Dimensionality: 3D<br/>Data Reliability: partial<br/>Count of attributes rated moderate or worse: 2</p>
<p>Note: Legacy support is provided for convenience and does not define the SSE-Lang syntax.</p>
<h2>9. Versioning Notes
	•	v0.1.1 defines input syntax only for the public judgement endpoint.
	•	SSE-Lang v0.1 rules remain the authoritative infeasibility criteria.
	•	Future versions may extend:
	•	typed units
	•	structured semantic units
	•	derived-field computation (e.g., automatically computing counts from ratings)
	•	formal proof/trace exports</h2>
<p>    </p>
<p></p>
  <div class="nav" style="margin-top:20px">Canonical source: SSE-Lang Input Syntax v0.1.1.</div>
</div>
</body>
</html>
